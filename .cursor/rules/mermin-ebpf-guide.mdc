---
alwaysApply: true
---

# Mermin eBPF Development Guide for AI Agents

This guide provides essential instructions for AI agents working with the Mermin project in Cursor IDE. It consolidates best practices for eBPF development with Aya in Rust.

## üö® Critical Rules - Always Follow

### 1. **MANDATORY: Use Docker for ALL eBPF Operations**

```bash
# Build the container first
docker build -t mermin-builder:latest --target builder .

# Use this pattern for ALL commands
docker run -it --privileged --mount type=bind,source=.,target=/app mermin-builder:latest /bin/bash -c "[COMMAND]"
```

**Why**: eBPF code CANNOT compile on non-Linux hosts (especially macOS). The Docker container provides the required Linux environment.

### 2. **Project Structure**

- `mermin/` - Main Kubernetes application
- `mermin-ebpf/` - eBPF programs (requires Linux compilation)
- `mermin-common/` - Shared types
- `network-types/` - Network protocol definitions
- `charts/mermin/` - Helm deployment charts

## üìã Common Development Tasks

### Building and Testing

```bash
# Build everything
docker run -it --privileged --mount type=bind,source=.,target=/app mermin-builder:latest /bin/bash -c "cargo build"

# Run tests
docker run -it --privileged --mount type=bind,source=.,target=/app mermin-builder:latest /bin/bash -c "cargo test"

# Check code quality
docker run -it --privileged --mount type=bind,source=.,target=/app mermin-builder:latest /bin/bash -c "cargo clippy -- -D warnings"
docker run -it --privileged --mount type=bind,source=.,target=/app mermin-builder:latest /bin/bash -c "cargo fmt"
```

### eBPF Program Analysis

```bash
# Count instructions (important for verification)
docker run -it --privileged --mount type=bind,source=.,target=/app mermin-builder:latest /bin/bash -c "bpftool prog dump xlated id <ID> | grep -E '^[0-9]+:' | wc -l"

# Check verification logs
docker run -it --privileged --mount type=bind,source=.,target=/app mermin-builder:latest /bin/bash -c "dmesg | grep -i 'bpf\|ebpf' | tail -20"
```

## üîß eBPF Development Patterns

### 1. **Bounded Loops (Required for Verification)**

```rust
// ‚ùå BAD - Will fail verification
while offset < ctx.len() as usize {
    // Unbounded loop
}

// ‚úÖ GOOD - Will pass verification
for _ in 0..1500 {  // Max Ethernet frame size
    if offset >= ctx.len() as usize {
        break;
    }
    // Process data
}
```

### 2. **Memory Access with Bounds Checking**

```rust
// ‚ùå BAD - Missing bounds check
let data: u32 = ctx.load(offset)?;

// ‚úÖ GOOD - Proper bounds checking
if offset + mem::size_of::<u32>() > ctx.len() as usize {
    return Err(Error::OutOfBounds);
}
let data: u32 = ctx.load(offset)?;
```

### 3. **Error Handling**

```rust
// Always handle errors gracefully
match parse_packet(&ctx) {
    Ok(data) => process_data(data),
    Err(_) => return Ok(TC_ACT_PIPE), // Pass packet through
}
```

### 4. **Map Operations**

```rust
#[map]
static mut FLOWS: HashMap<FlowKey, FlowStats> = HashMap::with_max_entries(10000, 0);

// Safe map access
unsafe {
    let stats = FLOWS.get(&key, 0).unwrap_or_default();
    // Update stats
    FLOWS.insert(&key, &stats, 0)?;
}
```

### 5. **eBPF Logging Best Practices**

- Minimize logging - Each log statement adds complexity
- Avoid format parameters when possible - they can cause verifier issues
- Use simple messages - complex formatting often fails verification
- Test without logging first - get your core logic working, then add logging

## üêõ Debugging and Troubleshooting

### Common Issues and Solutions

1. **Verification Failures**
   - Simplify control flow
   - Add explicit bounds to loops
   - Check stack usage (max 512 bytes)

2. **Build Errors**
   - Ensure you're using the Docker container
   - Run `cargo clean` before rebuilding
   - Check that eBPF target is installed

3. **Runtime Errors**
   - Use `aya_log_ebpf` for debugging
   - Check map permissions
   - Monitor with `bpftool`

### Debug Commands

```bash
# View loaded programs
docker run -it --privileged --mount type=bind,source=.,target=/app mermin-builder:latest /bin/bash -c "bpftool prog list"

# Inspect maps
docker run -it --privileged --mount type=bind,source=.,target=/app mermin-builder:latest /bin/bash -c "bpftool map list"

# Check program stats
docker run -it --privileged --mount type=bind,source=.,target=/app mermin-builder:latest /bin/bash -c "bpftool prog show name mermin"
```

## üöÄ Kubernetes Deployment

### Local Testing with Kind

```bash
# Create cluster
kind create cluster --config local/kind-config.yaml

# Build and load image
docker build -t mermin:latest --target runner-debug .
kind load docker-image -n atlantis mermin:latest

# Deploy with Helm
helm upgrade -i mermin charts/mermin --values local/values.yaml

# Check deployment
kubectl get pods -l app.kubernetes.io/name=mermin
kubectl logs -l app.kubernetes.io/name=mermin -f
```

## üìö Key Concepts for AI Agents

### eBPF Verifier Constraints

- **No dynamic memory allocation** - Use fixed-size arrays
- **No recursion** - Use iterative approaches
- **Bounded loops** - Must have provable upper limit
- **Limited stack** - Maximum 512 bytes
- **No unbounded memory access** - Always check bounds

### Performance Optimization

- Minimize instruction count
- Use single memory reads when possible
- Optimize map access patterns
- Avoid complex nested conditions

### Testing Best Practices

- Test with malformed packets
- Verify bounds checking
- Monitor instruction count
- Test error conditions

## üîó Quick Reference

### Essential Patterns

```rust
// Packet parsing structure
struct PacketParser {
    offset: usize,
}

// Protocol detection
match eth.ether_type {
    0x0800 => parse_ipv4(&ctx),
    0x86DD => parse_ipv6(&ctx),
    _ => return Ok(TC_ACT_PIPE),
}

// Flow tracking
let flow_key = FlowKey {
    src_ip: ip.src_addr,
    dst_ip: ip.dst_addr,
    src_port: tcp.src_port,
    dst_port: tcp.dst_port,
    protocol: ip.protocol,
};
```

## ‚ö†Ô∏è Important Reminders

1. **ALWAYS use Docker** for eBPF operations
2. **NEVER assume** direct compilation will work on macOS
3. **ALWAYS test** in containerized environment
4. **MONITOR** instruction count and complexity
5. **HANDLE errors** gracefully - don't drop packets unnecessarily

## üìû Getting Help

- Check verification logs with `dmesg`
- Use `bpftool` for runtime inspection
- Review Aya documentation at <https://aya-rs.dev/>
- Consult eBPF docs at <https://docs.ebpf.io/>

Remember: When in doubt, simplify your eBPF program. Complex logic often fails verification.
