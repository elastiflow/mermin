---
alwaysApply: true
---

# Mermin Development Rules for AI Agents

## Project Overview

Mermin is a Kubernetes-native network traffic observability tool that uses eBPF agents to capture network flow data and sends it via OpenTelemetry Collector protocol. The project consists of multiple Rust crates including eBPF programs, network type definitions, and Kubernetes integration.

## Core Development Principles

### 1. eBPF Development Requirements

- **ALWAYS** use the Docker containerized build environment for eBPF compilation
- **NEVER** attempt to compile eBPF code directly on non-Linux hosts (especially macOS)
- Use the `mermin-builder:latest` image for all cargo, bpftool, and llvm-objdump operations
- eBPF code is dual-licensed under GPL-2 or MIT - respect licensing requirements

### 2. Containerized Development Commands

```bash
# Build the builder image first
docker build -t mermin-builder:latest --target builder .

# All cargo operations must use the container
docker run -it --privileged --mount type=bind,source=.,target=/app mermin-builder:latest /bin/bash -c "cargo [COMMAND]"

# Examples:
docker run -it --privileged --mount type=bind,source=.,target=/app mermin-builder:latest /bin/bash -c "cargo test"
docker run -it --privileged --mount type=bind,source=.,target=/app mermin-builder:latest /bin/bash -c "cargo clippy"
docker run -it --privileged --mount type=bind,source=.,target=/app mermin-builder:latest /bin/bash -c "cargo build"
docker run -it --privileged --mount type=bind,source=.,target=/app mermin-builder:latest /bin/bash -c "cargo run"
```

### 3. Project Structure Understanding

- **mermin/**: Main application crate with Kubernetes integration
- **mermin-ebpf/**: eBPF programs for network packet processing
- **mermin-common/**: Shared utilities and types
- **network-types/**: Network protocol definitions and parsing logic
- **common-build/**: Build-time utilities
- **charts/mermin/**: Helm charts for Kubernetes deployment

### 4. Testing and Quality Assurance

- **Unit Tests**: Run with `cargo test` in the container
- **eBPF Tests**: Use `cargo test -p mermin-ebpf` for eBPF-specific tests
- **Integration Tests**: Located in `network-types/tests/` with their own Makefile
- **Linting**: Always run `cargo clippy` with `-- -D warnings` flag
- **Formatting**: Use `cargo fmt` for consistent code style

### 5. eBPF Program Analysis and Debugging

- **bpftool**: Use for runtime eBPF program inspection
- **llvm-objdump**: Use for static analysis of compiled eBPF binaries
- **Instruction Counting**: Monitor eBPF program complexity and performance
- **Memory Analysis**: Check memory usage and limits for eBPF programs

### 6. Network Protocol Development

- **Protocol Parsers**: Implement in the network-types crate
- **Integration Tests**: Use the test suite in `network-types/tests/`
- **eBPF Integration**: Ensure network parsing works with eBPF programs
- **Performance**: Monitor instruction counts and optimize parsing logic

### 7. Kubernetes Integration

- **Helm Charts**: Use the charts in `charts/mermin/`
- **Local Development**: Use `kind` cluster with `local/kind-config.yaml`
- **Deployment**: Use `make helm-upgrade` for local deployments
- **Debugging**: Use `kubectl debug` with netshoot for network analysis

### 8. Build and Deployment Workflow

1. **Local Development**: Use Docker container for all builds
2. **Testing**: Run tests in containerized environment
3. **Kubernetes Testing**: Use kind cluster for integration testing
4. **Production**: Build and deploy via Helm charts

### 9. Debugging and Troubleshooting

- **Network Capture**: Use Wireshark with kubectl debug for pod traffic analysis
- **eBPF Programs**: Use bpftool for program inspection and verification
- **Logs**: Check application logs with `kubectl logs`
- **Build Issues**: Clean with `cargo clean` and rebuild in container

### 10. Performance and Optimization

- **eBPF Instruction Counts**: Monitor and optimize program complexity
- **Memory Usage**: Track memory consumption and limits
- **Network Parsing**: Optimize protocol parsing for performance
- **Resource Limits**: Respect Kubernetes resource constraints

### 11. Security Considerations

- **Privileged Access**: eBPF programs require elevated privileges
- **Container Security**: Use appropriate security contexts in Kubernetes
- **Network Access**: Control network access and monitoring scope
- **Data Handling**: Ensure proper handling of network flow data

### 12. Development Best Practices

- **Error Handling**: Implement proper error handling in eBPF programs
- **Logging**: Use appropriate log levels and structured logging
- **Documentation**: Document complex eBPF logic and network parsing
- **Testing**: Write comprehensive tests for all new functionality
- **Code Review**: Ensure eBPF code follows safety best practices

### 13. Integration Points

- **OpenTelemetry**: Ensure proper integration with collector protocol
- **Kubernetes**: Follow Kubernetes-native patterns and best practices
- **Network Protocols**: Support standard and custom network protocols
- **Observability**: Integrate with monitoring and alerting systems

### 14. Common Development Tasks

- **Adding New Protocols**: Extend network-types and eBPF programs
- **Performance Tuning**: Optimize eBPF programs and parsing logic
- **Kubernetes Features**: Add new Kubernetes integration capabilities
- **Testing Infrastructure**: Improve test coverage and automation

### 15. Troubleshooting Common Issues

- **Build Failures**: Check container environment and dependencies
- **eBPF Loading**: Verify program verification and instruction limits
- **Network Issues**: Use debugging tools for traffic analysis
- **Kubernetes Deployment**: Check Helm chart configuration and resources

## Important Notes for AI Agents

- **ALWAYS** use the Docker container for eBPF operations
- **NEVER** assume direct compilation will work on non-Linux hosts
- **ALWAYS** check the project structure before making changes
- **ALWAYS** consider eBPF safety and performance implications
- **ALWAYS** test changes in the appropriate environment
- **ALWAYS** respect the dual-licensing requirements for eBPF code
- **ALWAYS** follow Kubernetes-native development patterns
- **ALWAYS** consider network security and privacy implications

# Mermin Development Rules for AI Agents

## Project Overview

Mermin is a Kubernetes-native network traffic observability tool that uses eBPF agents to capture network flow data and sends it via OpenTelemetry Collector protocol. The project consists of multiple Rust crates including eBPF programs, network type definitions, and Kubernetes integration.

## Core Development Principles

### 1. eBPF Development Requirements

- **ALWAYS** use the Docker containerized build environment for eBPF compilation
- **NEVER** attempt to compile eBPF code directly on non-Linux hosts (especially macOS)
- Use the `mermin-builder:latest` image for all cargo, bpftool, and llvm-objdump operations
- eBPF code is dual-licensed under GPL-2 or MIT - respect licensing requirements

### 2. Containerized Development Commands

```bash
# Build the builder image first
docker build -t mermin-builder:latest --target builder .

# All cargo operations must use the container
docker run -it --privileged --mount type=bind,source=.,target=/app mermin-builder:latest /bin/bash -c "cargo [COMMAND]"

# Examples:
docker run -it --privileged --mount type=bind,source=.,target=/app mermin-builder:latest /bin/bash -c "cargo test"
docker run -it --privileged --mount type=bind,source=.,target=/app mermin-builder:latest /bin/bash -c "cargo clippy"
docker run -it --privileged --mount type=bind,source=.,target=/app mermin-builder:latest /bin/bash -c "cargo build"
docker run -it --privileged --mount type=bind,source=.,target=/app mermin-builder:latest /bin/bash -c "cargo run"
```

### 3. Project Structure Understanding

- **mermin/**: Main application crate with Kubernetes integration
- **mermin-ebpf/**: eBPF programs for network packet processing
- **mermin-common/**: Shared utilities and types
- **network-types/**: Network protocol definitions and parsing logic
- **common-build/**: Build-time utilities
- **charts/mermin/**: Helm charts for Kubernetes deployment

### 4. Testing and Quality Assurance

- **Unit Tests**: Run with `cargo test` in the container
- **eBPF Tests**: Use `cargo test -p mermin-ebpf` for eBPF-specific tests
- **Integration Tests**: Located in `network-types/tests/` with their own Makefile
- **Linting**: Always run `cargo clippy` with `-- -D warnings` flag
- **Formatting**: Use `cargo fmt` for consistent code style

### 5. eBPF Program Analysis and Debugging

- **bpftool**: Use for runtime eBPF program inspection
- **llvm-objdump**: Use for static analysis of compiled eBPF binaries
- **Instruction Counting**: Monitor eBPF program complexity and performance
- **Memory Analysis**: Check memory usage and limits for eBPF programs

### 6. Network Protocol Development

- **Protocol Parsers**: Implement in the network-types crate
- **Integration Tests**: Use the test suite in `network-types/tests/`
- **eBPF Integration**: Ensure network parsing works with eBPF programs
- **Performance**: Monitor instruction counts and optimize parsing logic

### 7. Kubernetes Integration

- **Helm Charts**: Use the charts in `charts/mermin/`
- **Local Development**: Use `kind` cluster with `local/kind-config.yaml`
- **Deployment**: Use `make helm-upgrade` for local deployments
- **Debugging**: Use `kubectl debug` with netshoot for network analysis

### 8. Build and Deployment Workflow

1. **Local Development**: Use Docker container for all builds
2. **Testing**: Run tests in containerized environment
3. **Kubernetes Testing**: Use kind cluster for integration testing
4. **Production**: Build and deploy via Helm charts

### 9. Debugging and Troubleshooting

- **Network Capture**: Use Wireshark with kubectl debug for pod traffic analysis
- **eBPF Programs**: Use bpftool for program inspection and verification
- **Logs**: Check application logs with `kubectl logs`
- **Build Issues**: Clean with `cargo clean` and rebuild in container

### 10. Performance and Optimization

- **eBPF Instruction Counts**: Monitor and optimize program complexity
- **Memory Usage**: Track memory consumption and limits
- **Network Parsing**: Optimize protocol parsing for performance
- **Resource Limits**: Respect Kubernetes resource constraints

### 11. Security Considerations

- **Privileged Access**: eBPF programs require elevated privileges
- **Container Security**: Use appropriate security contexts in Kubernetes
- **Network Access**: Control network access and monitoring scope
- **Data Handling**: Ensure proper handling of network flow data

### 12. Development Best Practices

- **Error Handling**: Implement proper error handling in eBPF programs
- **Logging**: Use appropriate log levels and structured logging
- **Documentation**: Document complex eBPF logic and network parsing
- **Testing**: Write comprehensive tests for all new functionality
- **Code Review**: Ensure eBPF code follows safety best practices

### 13. Integration Points

- **OpenTelemetry**: Ensure proper integration with collector protocol
- **Kubernetes**: Follow Kubernetes-native patterns and best practices
- **Network Protocols**: Support standard and custom network protocols
- **Observability**: Integrate with monitoring and alerting systems

### 14. Common Development Tasks

- **Adding New Protocols**: Extend network-types and eBPF programs
- **Performance Tuning**: Optimize eBPF programs and parsing logic
- **Kubernetes Features**: Add new Kubernetes integration capabilities
- **Testing Infrastructure**: Improve test coverage and automation

### 15. Troubleshooting Common Issues

- **Build Failures**: Check container environment and dependencies
- **eBPF Loading**: Verify program verification and instruction limits
- **Network Issues**: Use debugging tools for traffic analysis
- **Kubernetes Deployment**: Check Helm chart configuration and resources

## Important Notes for AI Agents

- **ALWAYS** use the Docker container for eBPF operations
- **NEVER** assume direct compilation will work on non-Linux hosts
- **ALWAYS** check the project structure before making changes
- **ALWAYS** consider eBPF safety and performance implications
- **ALWAYS** test changes in the appropriate environment
- **ALWAYS** respect the dual-licensing requirements for eBPF code
- **ALWAYS** follow Kubernetes-native development patterns
- **ALWAYS** consider network security and privacy implications
