use core::mem;

use crate::ip::IpProto;

/// Fragment Extension Header Format
///
///  0                   1                   2                   3
///  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
/// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/// |  Next Header  |   Reserved    |      Fragment Offset    |Res|M|
/// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/// |                         Identification                        |
/// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
///
/// Fields
///
/// * **Next Header (8 bits)**: Identifies the type of the next header.
/// * **Reserved (8 bits)**: Initialized to all zeroes. Must be 0.
/// * **Fragment Offset (13 bits)**: Offset, in 8-octet units, relative to the
///   start of the fragmentable part of the original packet.
/// * **Res (2 bits)**: Reserved; initialized to zeroes. Must be 0.
/// * **M Flag (1 bit)**: 1 means more fragments follow; 0 means last fragment.
/// * **Identification (32 bits)**: Packet identification value, generated by the source node.
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FragmentHdr {
    /// This field identifies the type of the next header.
    pub next_hdr: IpProto,
    /// This is a reserved field that should be initialized to all zeros.
    pub reserved: u8,
    /// This field represents the first byte of the fragment offset.
    pub frag_offset: u8,
    /// This is a combined field containing:
    /// - 5-bit end of fragment offset field
    /// - 2-bit reserved field
    /// - 1-bit M flag
    pub fo_res_m: u8,
    /// This field stores the 4 bytes of the packet identification.
    pub id: [u8; 4],
}

impl FragmentHdr {
    pub const LEN: usize = mem::size_of::<FragmentHdr>();

    // --- Constants for bit manipulation within fo_res_m ---
    // FFFFFRM (F = fragment offset high bits, R = reserved, M = more fragments flag)
    const FRAG_OFFSET_UPPER_MASK_IN_BYTE: u8 = 0b11111000;
    const FRAG_OFFSET_UPPER_SHIFT: u8 = 3;
    const FRAG_OFFSET_UPPER_VALUE_MASK: u16 = 0x001F;

    const RESERVED2_MASK_IN_BYTE: u8 = 0b00000110;
    const RESERVED2_SHIFT: u8 = 1;
    const RESERVED2_VALUE_MASK: u8 = 0x03;

    const M_FLAG_MASK_IN_BYTE: u8 = 0b00000001;

    /// Gets the 13-bit Fragment Offset value.
    #[inline]
    pub fn fragment_offset(&self) -> u16 {
        // First 8 bits from frag_offset
        let lower_bits = (self.frag_offset as u16) << 5;
        // Upper 5 bits from fo_res_m
        let upper_bits = ((self.fo_res_m & Self::FRAG_OFFSET_UPPER_MASK_IN_BYTE)
            >> Self::FRAG_OFFSET_UPPER_SHIFT) as u16;
        lower_bits | upper_bits
    }

    /// Sets the 13-bit Fragment Offset value.
    /// Input `offset` should be a 13-bit integer (0 to 0x1FFF).
    #[inline]
    pub fn set_fragment_offset(&mut self, offset: u16) {
        // Mask input value with 13 set bits
        let masked_offset = offset & 0x1FFF;
        // Lower 8 bits go to frag_offset
        self.frag_offset = ((masked_offset >> 5) & 0xFF) as u8;
        // Upper 5 bits go to fo_res_m
        let upper_5bits = (masked_offset & Self::FRAG_OFFSET_UPPER_VALUE_MASK) as u8;
        let current_fo_res_m = self.fo_res_m;
        // Shift new bits to save into 5 MSB
        let new_fo_res_m = upper_5bits << Self::FRAG_OFFSET_UPPER_SHIFT;
        // Remove old fragment offset value via mask, OR in new value
        self.fo_res_m = (current_fo_res_m & !Self::FRAG_OFFSET_UPPER_MASK_IN_BYTE) | new_fo_res_m;
    }

    /// Gets the 2-bit Reserved2 value.
    #[inline]
    pub fn reserved2(&self) -> u8 {
        (self.fo_res_m & Self::RESERVED2_MASK_IN_BYTE) >> Self::RESERVED2_SHIFT
    }

    /// Sets the 2-bit Reserved2 value.
    /// Input `res` should be a 2-bit integer (0 to 3).
    #[inline]
    pub fn set_reserved2(&mut self, res: u8) {
        // Mask input value with 2 set bits
        let masked_res = res & Self::RESERVED2_VALUE_MASK;
        let current_fo_res_m = self.fo_res_m;
        // Shift new bits to correct position
        let new_fo_res_m = masked_res << Self::RESERVED2_SHIFT;
        // Remove old reserved2 value via mask, OR in new value
        self.fo_res_m = (current_fo_res_m & !Self::RESERVED2_MASK_IN_BYTE) | new_fo_res_m;
    }

    /// Gets the M Flag (More Fragments) value.
    #[inline]
    pub fn m_flag(&self) -> bool {
        (self.fo_res_m & Self::M_FLAG_MASK_IN_BYTE) != 0
    }

    /// Sets the M Flag (More Fragments) value.
    #[inline]
    pub fn set_m_flag(&mut self, flag: bool) {
        let current_fo_res_m = self.fo_res_m;
        if flag {
            // Set the M flag bit
            self.fo_res_m = current_fo_res_m | Self::M_FLAG_MASK_IN_BYTE;
        } else {
            // Clear the M flag bit
            self.fo_res_m = current_fo_res_m & !Self::M_FLAG_MASK_IN_BYTE;
        }
    }

    /// Gets the 32-bit Identification value.
    #[inline]
    pub fn identification(&self) -> u32 {
        let b0 = (self.id[0] as u32) << 24;
        let b1 = (self.id[1] as u32) << 16;
        let b2 = (self.id[2] as u32) << 8;
        let b3 = self.id[3] as u32;
        b0 | b1 | b2 | b3
    }

    /// Sets the 32-bit Identification value.
    #[inline]
    pub fn set_identification(&mut self, id: u32) {
        self.id[0] = ((id >> 24) & 0xFF) as u8;
        self.id[1] = ((id >> 16) & 0xFF) as u8;
        self.id[2] = ((id >> 8) & 0xFF) as u8;
        self.id[3] = (id & 0xFF) as u8;
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fragment_offset() {
        let mut fragment = FragmentHdr {
            next_hdr: IpProto::Stream,
            reserved: 0,
            frag_offset: 0,
            fo_res_m: 0,
            id: [0; 4],
        };

        // Test setting and getting fragment offset
        fragment.set_fragment_offset(0x1FFF); // Max value (all 13 bits set)
        assert_eq!(fragment.fragment_offset(), 0x1FFF);

        fragment.set_fragment_offset(0x1234);
        assert_eq!(fragment.fragment_offset(), 0x1234);

        // Test that values outside the 13-bit range are masked
        fragment.set_fragment_offset(0xFFFF);
        assert_eq!(fragment.fragment_offset(), 0x1FFF); // Only 13 bits should be set
    }

    #[test]
    fn test_reserved2() {
        let mut fragment = FragmentHdr {
            next_hdr: IpProto::Stream,
            reserved: 0,
            frag_offset: 0,
            fo_res_m: 0,
            id: [0; 4],
        };

        // Test setting and getting reserved2
        fragment.set_reserved2(3); // Max value (both bits set)
        assert_eq!(fragment.reserved2(), 3);

        fragment.set_reserved2(2);
        assert_eq!(fragment.reserved2(), 2);

        // Test that values outside the 2-bit range are masked
        fragment.set_reserved2(0xFF);
        assert_eq!(fragment.reserved2(), 3); // Only 2 bits should be set
    }

    #[test]
    fn test_m_flag() {
        let mut fragment = FragmentHdr {
            next_hdr: IpProto::Stream,
            reserved: 0,
            frag_offset: 0,
            fo_res_m: 0,
            id: [0; 4],
        };

        // Test setting and getting m_flag
        fragment.set_m_flag(true);
        assert_eq!(fragment.m_flag(), true);

        fragment.set_m_flag(false);
        assert_eq!(fragment.m_flag(), false);
    }

    #[test]
    fn test_identification() {
        let mut fragment = FragmentHdr {
            next_hdr: IpProto::Stream,
            reserved: 0,
            frag_offset: 0,
            fo_res_m: 0,
            id: [0; 4],
        };

        // Test setting and getting identification
        fragment.set_identification(0xFFFFFFFF); // Max value
        assert_eq!(fragment.identification(), 0xFFFFFFFF);

        fragment.set_identification(0x12345678);
        assert_eq!(fragment.identification(), 0x12345678);
    }

    #[test]
    fn test_combined_fields() {
        let mut fragment = FragmentHdr {
            next_hdr: IpProto::Stream,
            reserved: 0,
            frag_offset: 0,
            fo_res_m: 0,
            id: [0; 4],
        };

        // Set all fields
        fragment.set_fragment_offset(0x1ABC);
        fragment.set_reserved2(2);
        fragment.set_m_flag(true);
        fragment.set_identification(0x12345678);

        // Verify all fields
        assert_eq!(fragment.fragment_offset(), 0x1ABC);
        assert_eq!(fragment.reserved2(), 2);
        assert_eq!(fragment.m_flag(), true);
        assert_eq!(fragment.identification(), 0x12345678);

        // Verify that setting one field doesn't affect others
        fragment.set_fragment_offset(0x0DEF);
        assert_eq!(fragment.fragment_offset(), 0x0DEF);
        assert_eq!(fragment.reserved2(), 2); // Should remain unchanged
        assert_eq!(fragment.m_flag(), true); // Should remain unchanged

        fragment.set_reserved2(1);
        assert_eq!(fragment.fragment_offset(), 0x0DEF); // Should remain unchanged
        assert_eq!(fragment.reserved2(), 1);
        assert_eq!(fragment.m_flag(), true); // Should remain unchanged

        fragment.set_m_flag(false);
        assert_eq!(fragment.fragment_offset(), 0x0DEF); // Should remain unchanged
        assert_eq!(fragment.reserved2(), 1); // Should remain unchanged
        assert_eq!(fragment.m_flag(), false);
    }
}
